export type PRDContent = {
  title: string;
  problem: string;
  solution: string;
  objectives: string[];
  userStories: string[];
  requirements: string[];
};

export type PRDSections = {
  problem: boolean;
  solution: boolean;
  objectives?: boolean;
  userStories: boolean;
  requirements: boolean;
};

export type IntegrationConfig = {
  jiraBaseUrl?: string; // e.g., https://yourcompany.atlassian.net
  linearWorkspace?: string; // e.g., your-workspace
  // Hints used to prefix titles/descriptions for routing context (no API binding)
  jiraProjectHint?: string;
  jiraProjectKey?: string; // new explicit project key for API sync
  linearTeamHint?: string;
};

const CONFIG_KEY = 'pmcopilot_integrations';

// Optional backend usage
let backendApi: any = null;
let backendCheckDone = false;
async function ensureBackend() {
  if (backendCheckDone) return backendApi;
  backendCheckDone = true;
  try {
    const mod = await import('./api');
    if (mod.backendEnabled && mod.backendEnabled()) backendApi = mod.Api;
  } catch { /* ignore */ }
  return backendApi;
}

export function getIntegrationConfig(): IntegrationConfig {
  try {
    const raw = localStorage.getItem(CONFIG_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch {
    return {};
  }
}

export function setIntegrationConfig(cfg: IntegrationConfig) {
  try { localStorage.setItem(CONFIG_KEY, JSON.stringify(cfg)); } catch {}
}

export function prdToMarkdown(prd: PRDContent, sections: PRDSections, opts?: { score?: number | null; gaps?: string[] }) {
  const parts: string[] = [];
  parts.push(`# ${prd.title || 'Product Requirements Document'}`);
  if (sections.problem) {
    parts.push('', '## Problem Statement', prd.problem || '—');
  }
  if (sections.solution) {
    parts.push('', '## Solution Overview', prd.solution || '—');
  }
  if (sections.solution && sections.objectives) {
    parts.push('', '## Objectives & Success Metrics');
    parts.push((prd.objectives || []).map((o, i) => `${i + 1}. ${o}`).join('\n') || '—');
  }
  if (sections.userStories) {
    parts.push('', '## User Stories');
    parts.push((prd.userStories || []).map((s, i) => `${i + 1}. ${s}`).join('\n') || '—');
  }
  if (sections.requirements) {
    parts.push('', '## Requirements');
    parts.push((prd.requirements || []).map((r, i) => `${i + 1}. ${r}`).join('\n') || '—');
  }
  if (opts && (opts.score != null || (opts.gaps && opts.gaps.length))) {
    parts.push('', '## Completeness');
    if (opts.score != null) parts.push(`Gemini Score: ${opts.score}/100`);
    if (opts.gaps && opts.gaps.length) parts.push(`Gaps: ${opts.gaps.join(', ')}`);
  }
  parts.push('', '---', '*Generated by PM Copilot*');
  return parts.join('\n');
}

export function arrayToCSV(rows: string[][]): string {
  const esc = (v: string) => {
    const s = String(v ?? '');
    if (/[",\n]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
    return s;
  };
  return rows.map(r => r.map(esc).join(',')).join('\n');
}

export function downloadTextFile(filename: string, mime: string, content: string) {
  const blob = new Blob([content], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

export function exportStoriesCSV(stories: string[]) {
  const rows = [['Story'], ...stories.map(s => [s])];
  downloadTextFile('user_stories.csv', 'text/csv', arrayToCSV(rows));
}

export function exportRequirementsCSV(reqs: string[]) {
  const rows = [['Requirement'], ...reqs.map(r => [r])];
  downloadTextFile('requirements.csv', 'text/csv', arrayToCSV(rows));
}

export async function copyToClipboard(text: string) {
  try { await navigator.clipboard.writeText(text); } catch {}
}

export async function openGoogleDocsWithContentCopied(markdown: string) {
  await copyToClipboard(markdown);
  window.open('https://docs.google.com/document/create', '_blank');
}

export async function openNotionWithContentCopied(markdown: string) {
  await copyToClipboard(markdown);
  // Notion cannot prefill via URL; open homepage/new page
  window.open('https://www.notion.so/', '_blank');
}

// Linear & Jira web intents (best-effort, may vary by workspace)
export function openLinearIssue(workspace: string, title: string, description?: string) {
  if (!workspace) return;
  const base = `https://linear.app/${encodeURIComponent(workspace)}/issue/new`;
  const url = `${base}?title=${encodeURIComponent(title)}${description ? `&description=${encodeURIComponent(description)}` : ''}`;
  window.open(url, '_blank');
}

export function openJiraIssue(baseUrl: string, summary: string, description?: string) {
  if (!baseUrl) return;
  const base = baseUrl.replace(/\/$/, '');
  const url = `${base}/secure/CreateIssueDetails!init.jspa?summary=${encodeURIComponent(summary)}${description ? `&description=${encodeURIComponent(description)}` : ''}`;
  window.open(url, '_blank');
}

export async function syncItemsToLinear(items: string[], workspace: string, limit = 5): Promise<{ opened: number; copied: number }> {
  // If backend available and more than 0 items, try API creation (no limit slicing except optional)
  const api = await ensureBackend();
  if (api) {
    try {
      const cfg = getIntegrationConfig();
      const hint = cfg.linearTeamHint ? `[${cfg.linearTeamHint}] ` : '';
      const payload = items.slice(0, limit).map(t => ({ title: hint + t }));
      const res = await api.syncLinear(payload);
      return { opened: res.created?.length || 0, copied: 0 };
    } catch {
      // fallback to legacy web intent
    }
  }
  const slice = items.slice(0, limit);
  let opened = 0;
  let copied = 0;
  if (slice.length > 0) {
    // Open first issue immediately to preserve user gesture and avoid popup blockers
  const cfg = getIntegrationConfig();
  const hint = cfg.linearTeamHint ? `[${cfg.linearTeamHint}] ` : '';
  openLinearIssue(workspace, hint + slice[0]);
    opened = 1;
  }
  if (slice.length > 1) {
  const cfg = getIntegrationConfig();
  const hint = cfg.linearTeamHint ? `[${cfg.linearTeamHint}] ` : '';
  const rest = slice.slice(1).map((t) => `• ${hint}${t}`).join('\n');
    await copyToClipboard(rest);
    copied = slice.length - 1;
  }
  return { opened, copied };
}

export async function syncItemsToJira(items: string[], baseUrl: string, limit = 5): Promise<{ opened: number; copied: number }> {
  const api = await ensureBackend();
  if (api) {
    try {
      const cfg = getIntegrationConfig();
      const hint = cfg.jiraProjectHint ? `[${cfg.jiraProjectHint}] ` : '';
  // prefer explicit project key; fallback heuristic or placeholder
  const projectKey = cfg.jiraProjectKey || (cfg.jiraProjectHint && /[A-Z]{2,}/.test(cfg.jiraProjectHint) ? cfg.jiraProjectHint : 'PROJ');
      const payload = items.slice(0, limit).map(t => ({ summary: hint + t, projectKey }));
      const res = await api.syncJira(payload);
      return { opened: res.created?.length || 0, copied: 0 };
    } catch {
      // fallback to web intent mode
    }
  }
  const slice = items.slice(0, limit);
  let opened = 0;
  let copied = 0;
  if (slice.length > 0) {
  const cfg = getIntegrationConfig();
  const hint = cfg.jiraProjectHint ? `[${cfg.jiraProjectHint}] ` : '';
  openJiraIssue(baseUrl, hint + slice[0]);
    opened = 1;
  }
  if (slice.length > 1) {
  const cfg = getIntegrationConfig();
  const hint = cfg.jiraProjectHint ? `[${cfg.jiraProjectHint}] ` : '';
  const rest = slice.slice(1).map((t) => `• ${hint}${t}`).join('\n');
    await copyToClipboard(rest);
    copied = slice.length - 1;
  }
  return { opened, copied };
}
