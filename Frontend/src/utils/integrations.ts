import type { PRDContent, PRDSections } from '@core';

export type IntegrationConfig = {
  jiraBaseUrl?: string; // e.g., https://yourcompany.atlassian.net
  linearWorkspace?: string; // e.g., your-workspace
  // Hints used to prefix titles/descriptions for routing context (no API binding)
  jiraProjectHint?: string;
  jiraProjectKey?: string; // new explicit project key for API sync
  linearTeamHint?: string;
};

const CONFIG_KEY = 'pmcopilot_integrations';

// Optional backend usage
let backendApi: any = null;
let backendCheckDone = false;
async function ensureBackend() {
  if (backendCheckDone) return backendApi;
  backendCheckDone = true;
  try {
    const mod = await import('./api');
    if (mod.backendEnabled && mod.backendEnabled()) backendApi = mod.Api;
  } catch { /* ignore */ }
  return backendApi;
}

export function getIntegrationConfig(): IntegrationConfig {
  try {
    const raw = localStorage.getItem(CONFIG_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch {
    return {};
  }
}

export function setIntegrationConfig(cfg: IntegrationConfig) {
  try { localStorage.setItem(CONFIG_KEY, JSON.stringify(cfg)); } catch {}
}

import { metric, isTelemetryEnabled } from './telemetry';

function timed<T>(name: string, data: Record<string, any>, fn: () => T): T {
  const start = typeof performance !== 'undefined' ? performance.now() : Date.now();
  try { return fn(); } finally {
    if (isTelemetryEnabled()) metric(name, { ms: Math.round((typeof performance !== 'undefined' ? performance.now() : Date.now()) - start), ...data });
  }
}

function addListSection(parts: string[], heading: string, items: string[] | undefined) {
  parts.push('', heading);
  parts.push((items || []).map((v, i) => `${i + 1}. ${v}`).join('\n') || '—');
}

function addTextSection(parts: string[], heading: string, body: string) {
  parts.push('', heading, body || '—');
}

function addCompleteness(parts: string[], opts?: { score?: number | null; gaps?: string[] }) {
  if (!opts) return;
  const { score, gaps } = opts;
  if (score == null && !(gaps && gaps.length)) return;
  parts.push('', '## Completeness');
  if (score != null) parts.push(`Gemini Score: ${score}/100`);
  if (gaps && gaps.length) parts.push(`Gaps: ${gaps.join(', ')}`);
}

export function prdToMarkdown(prd: PRDContent, sections: PRDSections, opts?: { score?: number | null; gaps?: string[] }) {
  const parts: string[] = [];
  parts.push(`# ${prd.title || 'Product Requirements Document'}`);
  if (sections.problem) addTextSection(parts, '## Problem Statement', prd.problem);
  if (sections.solution) addTextSection(parts, '## Solution Overview', prd.solution);
  if (sections.solution && sections.objectives) addListSection(parts, '## Objectives & Success Metrics', prd.objectives);
  if (sections.userStories) addListSection(parts, '## User Stories', prd.userStories);
  if (sections.requirements) addListSection(parts, '## Requirements', prd.requirements);
  addCompleteness(parts, opts);
  parts.push('', '---', '*Generated by PM Copilot*');
  const md = parts.join('\n');
  if (isTelemetryEnabled()) metric('export_markdown', { length: md.length, sections: Object.keys(sections).filter(k => (sections as any)[k]).length, hasScore: opts?.score != null, hasGaps: !!(opts?.gaps && opts.gaps.length) });
  return md;
}

export function arrayToCSV(rows: string[][]): string {
  const esc = (v: string) => {
    const s = String(v ?? '');
    if (/[",\n]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
    return s;
  };
  return rows.map(r => r.map(esc).join(',')).join('\n');
}

export function downloadTextFile(filename: string, mime: string, content: string) {
  const blob = new Blob([content], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

export function exportStoriesCSV(stories: string[]) {
  timed('export_csv', { type: 'stories', rows: stories.length }, () => {
    const rows = [['Story'], ...stories.map(s => [s])];
    downloadTextFile('user_stories.csv', 'text/csv', arrayToCSV(rows));
  });
}

export function exportRequirementsCSV(reqs: string[]) {
  timed('export_csv', { type: 'requirements', rows: reqs.length }, () => {
    const rows = [['Requirement'], ...reqs.map(r => [r])];
    downloadTextFile('requirements.csv', 'text/csv', arrayToCSV(rows));
  });
}

export async function copyToClipboard(text: string) {
  try { await navigator.clipboard.writeText(text); } catch {}
}

export async function openGoogleDocsWithContentCopied(markdown: string) {
  await copyToClipboard(markdown);
  window.open('https://docs.google.com/document/create', '_blank');
}

export async function openNotionWithContentCopied(markdown: string) {
  await copyToClipboard(markdown);
  // Notion cannot prefill via URL; open homepage/new page
  window.open('https://www.notion.so/', '_blank');
}

// Linear & Jira web intents (best-effort, may vary by workspace)
export function openLinearIssue(workspace: string, title: string, description?: string) {
  if (!workspace) return;
  const base = `https://linear.app/${encodeURIComponent(workspace)}/issue/new`;
  const url = `${base}?title=${encodeURIComponent(title)}${description ? `&description=${encodeURIComponent(description)}` : ''}`;
  window.open(url, '_blank');
}

export function openJiraIssue(baseUrl: string, summary: string, description?: string) {
  if (!baseUrl) return;
  const base = baseUrl.replace(/\/$/, '');
  const url = `${base}/secure/CreateIssueDetails!init.jspa?summary=${encodeURIComponent(summary)}${description ? `&description=${encodeURIComponent(description)}` : ''}`;
  window.open(url, '_blank');
}

export async function syncItemsToLinear(items: string[], workspace: string, limit = 5): Promise<{ opened: number; copied: number }> {
  // If backend available and more than 0 items, try API creation (no limit slicing except optional)
  const api = await ensureBackend();
  if (api) {
    try {
      const cfg = getIntegrationConfig();
      const hint = cfg.linearTeamHint ? `[${cfg.linearTeamHint}] ` : '';
      const payload = items.slice(0, limit).map(t => ({ title: hint + t }));
      const res = await api.syncLinear(payload);
      return { opened: res.created?.length || 0, copied: 0 };
    } catch {
      // fallback to legacy web intent
    }
  }
  const slice = items.slice(0, limit);
  let opened = 0;
  let copied = 0;
  if (slice.length > 0) {
    // Open first issue immediately to preserve user gesture and avoid popup blockers
  const cfg = getIntegrationConfig();
  const hint = cfg.linearTeamHint ? `[${cfg.linearTeamHint}] ` : '';
  openLinearIssue(workspace, hint + slice[0]);
    opened = 1;
  }
  if (slice.length > 1) {
  const cfg = getIntegrationConfig();
  const hint = cfg.linearTeamHint ? `[${cfg.linearTeamHint}] ` : '';
  const rest = slice.slice(1).map((t) => `• ${hint}${t}`).join('\n');
    await copyToClipboard(rest);
    copied = slice.length - 1;
  }
  return { opened, copied };
}

export async function syncItemsToJira(items: string[], baseUrl: string, limit = 5): Promise<{ opened: number; copied: number }> {
  const api = await ensureBackend();
  if (api) {
    try {
      const cfg = getIntegrationConfig();
      const hint = cfg.jiraProjectHint ? `[${cfg.jiraProjectHint}] ` : '';
  // prefer explicit project key; fallback heuristic or placeholder
  const projectKey = cfg.jiraProjectKey || (cfg.jiraProjectHint && /[A-Z]{2,}/.test(cfg.jiraProjectHint) ? cfg.jiraProjectHint : 'PROJ');
      const payload = items.slice(0, limit).map(t => ({ summary: hint + t, projectKey }));
      const res = await api.syncJira(payload);
      return { opened: res.created?.length || 0, copied: 0 };
    } catch {
      // fallback to web intent mode
    }
  }
  const slice = items.slice(0, limit);
  let opened = 0;
  let copied = 0;
  if (slice.length > 0) {
  const cfg = getIntegrationConfig();
  const hint = cfg.jiraProjectHint ? `[${cfg.jiraProjectHint}] ` : '';
  openJiraIssue(baseUrl, hint + slice[0]);
    opened = 1;
  }
  if (slice.length > 1) {
  const cfg = getIntegrationConfig();
  const hint = cfg.jiraProjectHint ? `[${cfg.jiraProjectHint}] ` : '';
  const rest = slice.slice(1).map((t) => `• ${hint}${t}`).join('\n');
    await copyToClipboard(rest);
    copied = slice.length - 1;
  }
  return { opened, copied };
}
